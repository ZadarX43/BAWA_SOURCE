# -*- coding: utf-8 -*-
"""BAWA_Preprocessing_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nYeIyi0dA8Bg3zRXexMZEjdc1TTm9vwP
"""

def load_and_preprocess(path, league_name):
    # Load each dataset
    team_stats = pd.read_csv(f'{path}{league_name}-teams-2023-to-2024-stats (1).csv')
    player_stats = pd.read_csv(f'{path}{league_name}-players-2023-to-2024-stats (1).csv')
    match_stats = pd.read_csv(f'{path}{league_name}-matches-2023-to-2024-stats (1).csv')
    league_stats = pd.read_csv(f'{path}{league_name}-league-2023-to-2024-stats (1).csv')

    # Preprocessing steps (you need to customize this to your data)
    # For example, if you want to merge match_stats and team_stats on team names:
    # Ensure that the team names match exactly in both dataframes, or map them to be the same.
    merged_df = pd.merge(match_stats, team_stats, left_on='home_team_name', right_on='team_name', how='left')

    # Add more preprocessing steps as needed, such as merging with player_stats and league_stats
    # and handle missing values, create new features, etc.

    # Assuming merged_df is your final merged DataFrame after all preprocessing
    return merged_df

"""Loading Data: It uses the pandas library to load various CSV files containing team, player, match, and league statistics for different football leagues. Each league has a unique file naming convention which is handled by the suffixes dictionary.

File Suffix Handling: The dictionary suffixes maps each league name to a specific suffix that is appended to the file names, allowing the correct files to be loaded for each league. Some leagues do not have a suffix, and this is handled by providing an empty string for those cases.

Data Preprocessing: After loading, the snippet merges the match statistics with team statistics twiceâ€”once for home team data and once for away team data. This is done using the pd.merge function, with appropriate suffixes to differentiate between home and away team stats.

Data Aggregation: All preprocessed data frames for each league are then appended into a list, which is finally concatenated into one comprehensive DataFrame using pd.concat. This combined DataFrame could be used for further analysis or model training.

Flexibility: The structure of the code allows for easy addition of more leagues and file suffixes, as well as additional preprocessing steps as needed.

Error Handling: The code also successfully avoids FileNotFoundError by correctly referencing the file paths and names for each league's dataset.
"""

import pandas as pd
from sklearn.model_selection import train_test_split

# Complete list of suffixes for the specified leagues
suffixes = {
    'europe-uefa-champions-league': ' (3)',
    'europe-uefa-europa-league': ' (1)',
    'europe-uefa-europa-conference-league': ' (1)',
    'england-premier-league': ' (2)',
    'spain-la-liga': ' (1)',
    'germany-bundesliga': ' (1)',
    'france-ligue-1': ' (1)',
    'portugal-liga-nos': ' (1)',
    'scotland-premiership': ' (1)',
    'italy-serie-a': ' (1)',
    'england-championship': ''  # Assuming no suffix for this league
}

def load_and_preprocess_all_leagues(path, league_names, suffixes):
    all_leagues_data = []
    for league_name in league_names:
        file_suffix = suffixes.get(league_name, '')

        # Load each dataset for the league with the appropriate file suffix
        team_stats = pd.read_csv(f'{path}{league_name}-teams-2023-to-2024-stats{file_suffix}.csv')
        player_stats = pd.read_csv(f'{path}{league_name}-players-2023-to-2024-stats{file_suffix}.csv')
        match_stats = pd.read_csv(f'{path}{league_name}-matches-2023-to-2024-stats{file_suffix}.csv')
        league_stats = pd.read_csv(f'{path}{league_name}-league-2023-to-2024-stats{file_suffix}.csv')

        # Preprocessing steps for each league
        merged_df = pd.merge(match_stats, team_stats, left_on='home_team_name', right_on='team_name', how='left')
        merged_df = pd.merge(merged_df, team_stats, left_on='away_team_name', right_on='team_name', how='left', suffixes=('_home', '_away'))

        # Add more preprocessing steps as needed

        # Append the processed DataFrame to the list
        all_leagues_data.append(merged_df)

    # Concatenate all league data into one DataFrame
    combined_df = pd.concat(all_leagues_data, ignore_index=True)
    return combined_df

# List of league names for which to load and preprocess data
league_names = [
    'europe-uefa-champions-league',
    'europe-uefa-europa-league',
    'europe-uefa-europa-conference-league',
    'england-premier-league',
    'spain-la-liga',
    'germany-bundesliga',
    'france-ligue-1',
    'portugal-liga-nos',
    'scotland-premiership',
    'italy-serie-a',
    'england-championship'
]

# Replace with your actual file path
path_to_files = '/content/drive/My Drive/94_betting_model/'

# Load and preprocess data for all leagues
combined_leagues_df = load_and_preprocess_all_leagues(path_to_files, league_names, suffixes)

def load_and_preprocess(path, league_name):
    file_suffix = "(1)"  # Adjust based on the league's specific naming convention

    # Load each dataset with the appropriate file suffix
    team_stats = pd.read_csv(f'{path}{league_name}-teams-2023-to-2024-stats{file_suffix}.csv')
    player_stats = pd.read_csv(f'{path}{league_name}-players-2023-to-2024-stats{file_suffix}.csv')
    match_stats = pd.read_csv(f'{path}{league_name}-matches-2023-to-2024-stats{file_suffix}.csv')
    league_stats = pd.read_csv(f'{path}{league_name}-league-2023-to-2024-stats{file_suffix}.csv')

    # Merge team stats with match stats on the home team name
    merged_df = pd.merge(match_stats, team_stats, left_on='home_team_name', right_on='team_name', how='left')

    # Then merge the result with the away team stats
    merged_df = pd.merge(merged_df, team_stats, left_on='away_team_name', right_on='team_name', how='left', suffixes=('_home', '_away'))

    # Additional preprocessing steps as required...

    # Return the preprocessed dataframe
    return merged_df

import pandas as pd
from sklearn.model_selection import train_test_split

# Complete list of suffixes for the specified leagues
suffixes = {
    'europe-uefa-champions-league': ' (3)',
    'europe-uefa-europa-league': ' (1)',
    'europe-uefa-europa-conference-league': ' (1)',
    'england-premier-league': ' (2)',
    'spain-la-liga': ' (1)',
    'germany-bundesliga': ' (1)',
    'france-ligue-1': ' (1)',
    'portugal-liga-nos': ' (1)',
    'scotland-premiership': ' (1)',
    'italy-serie-a': ' (1)',
    'england-championship': ''  # Assuming no suffix for this league
}

def load_and_preprocess_all_leagues(path, league_names, suffixes):
    all_leagues_data = []
    for league_name in league_names:
        file_suffix = suffixes.get(league_name, '')

        # Load each dataset for the league with the appropriate file suffix
        team_stats = pd.read_csv(f'{path}{league_name}-teams-2023-to-2024-stats{file_suffix}.csv')
        player_stats = pd.read_csv(f'{path}{league_name}-players-2023-to-2024-stats{file_suffix}.csv')
        match_stats = pd.read_csv(f'{path}{league_name}-matches-2023-to-2024-stats{file_suffix}.csv')
        league_stats = pd.read_csv(f'{path}{league_name}-league-2023-to-2024-stats{file_suffix}.csv')

        # Preprocessing steps for each league
        merged_df = pd.merge(match_stats, team_stats, left_on='home_team_name', right_on='team_name', how='left')
        merged_df = pd.merge(merged_df, team_stats, left_on='away_team_name', right_on='team_name', how='left', suffixes=('_home', '_away'))

        # Add more preprocessing steps as needed
        # ...

        # Append the processed DataFrame to the list
        all_leagues_data.append(merged_df)

    # Concatenate all league data into one DataFrame
    combined_df = pd.concat(all_leagues_data, ignore_index=True)
    return combined_df

# List of league names for which to load and preprocess data
league_names = [
    'europe-uefa-champions-league',
    'europe-uefa-europa-league',
    'europe-uefa-europa-conference-league',
    'england-premier-league',
    'spain-la-liga',
    'germany-bundesliga',
    'france-ligue-1',
    'portugal-liga-nos',
    'scotland-premiership',
    'italy-serie-a',
    'england-championship'
]

# Replace with your actual file path
path_to_files = '/content/drive/My Drive/94_betting_model/'

# Load and preprocess data for all leagues
combined_leagues_df = load_and_preprocess_all_leagues(path_to_files, league_names, suffixes)

"""Function to calculate form for a given number of matches

To implement the Full-Time Result (FTR) calculation along with other necessary statistics, you can use the following steps:

Calculate Team Form: This function calculates the form of each team over the last 'n' matches.

Calculate Head-to-Head Statistics: This function calculates head-to-head statistics between two teams.

Create FTR Column: This function adds a new column to your DataFrame that indicates the full-time result of each match.

Here's the code for these steps:
"""

import pandas as pd

# Function to calculate form for a given number of matches
def calculate_form(df, team_name, n_matches=5):
    recent_matches = df[(df['home_team_name'] == team_name) | (df['away_team_name'] == team_name)]
    recent_matches = recent_matches.sort_values('date_GMT').tail(n_matches)
    points = 0
    for index, row in recent_matches.iterrows():
        if row['home_team_name'] == team_name:
            if row['home_team_goal_count'] > row['away_team_goal_count']:
                points += 3  # Home win
            elif row['home_team_goal_count'] == row['away_team_goal_count']:
                points += 1  # Draw
        else:  # Away team
            if row['away_team_goal_count'] > row['home_team_goal_count']:
                points += 3  # Away win
            elif row['away_team_goal_count'] == row['home_team_goal_count']:
                points += 1  # Draw
    return points / (3 * n_matches)  # Average points per match

# Function to calculate head-to-head statistics
def calculate_head_to_head_stats(df, team1, team2):
    matches = df[((df['home_team_name'] == team1) & (df['away_team_name'] == team2)) |
                 ((df['home_team_name'] == team2) & (df['away_team_name'] == team1))]
    home_wins = len(matches[(matches['home_team_name'] == team1) & (matches['home_team_goal_count'] > matches['away_team_goal_count'])])
    away_wins = len(matches[(matches['home_team_name'] == team2) & (matches['home_team_goal_count'] < matches['away_team_goal_count'])])
    draws = len(matches[matches['home_team_goal_count'] == matches['away_team_goal_count']])
    return {'home_wins': home_wins, 'away_wins': away_wins, 'draws': draws}

# Function to create FTR column
def create_ftr_column(df):
    df['FTR'] = df.apply(lambda row: 0 if row['home_team_goal_count'] > row['away_team_goal_count'] else 1, axis=1)

# Apply these functions to your DataFrame
# Assuming 'combined_leagues_df' is your main DataFrame
combined_leagues_df['home_team_form'] = combined_leagues_df.apply(lambda row: calculate_form(combined_leagues_df, row['home_team_name']), axis=1)
combined_leagues_df['away_team_form'] = combined_leagues_df.apply(lambda row: calculate_form(combined_leagues_df, row['away_team_name']), axis=1)
combined_leagues_df['head_to_head'] = combined_leagues_df.apply(lambda row: calculate_head_to_head_stats(combined_leagues_df, row['home_team_name'], row['away_team_name']), axis=1)
create_ftr_column(combined_leagues_df)

# Now your DataFrame will have new columns for team form, head-to-head stats, and FTR





"""Data Preprocessing

"""

import joblib

# Load the model from the file
model_path = '/content/drive/My Drive/94_betting_model/94_betting_model.pkl'  # Update with your correct path
model = joblib.load(model_path)

# Assuming 'combined_leagues_df' is your new data
# And 'selected_features' are the features used by the model
selected_features = ['Pre-Match PPG (Home)', 'Pre-Match PPG (Away)', 'home_team_goal_count', 'away_team_goal_count', 'average_corners_per_match_pre_match', 'average_cards_per_match_pre_match', 'odds_ft_home_team_win', 'odds_ft_draw', 'odds_ft_away_team_win']

# Select the features from your new data
X_new = combined_leagues_df[selected_features]

# Make predictions
predictions = model.predict(X_new)

# Add predictions to the DataFrame
combined_leagues_df['Predicted_FTR'] = predictions

# Optionally, you can save the DataFrame with predictions to a new CSV file
combined_leagues_df.to_csv('/content/drive/My Drive/94_betting_model/predictions.csv', index=False)

"""Form Calculation: It calculates the recent form of teams based on their last n matches, helping to understand recent performance trends.

Head-to-Head Statistics: This function computes historical match outcomes between two teams, useful for understanding rivalry dynamics and historical dominance.

Feature Engineering: The create_ftr_column function creates a feature for match results, and additional columns are added for team forms and head-to-head stats, enriching your dataset for better model predictions.

Model Prediction: It loads a pre-trained model using joblib, selects relevant features from the processed data, and makes predictions on match results. These predictions are then added to your dataset.

Saving Predictions: Finally, the processed DataFrame, now with predictions, is saved to a CSV file, making it easy to analyze or share the model's output.
"""



import pandas as pd

# Load the datasets
cleaned_teams_path = 'cleaned_teams_head_to_head.csv'
cleaned_matches_path = 'cleaned_matches.csv'

# Read the data into pandas dataframes
cleaned_teams_data = pd.read_csv(cleaned_teams_path)
cleaned_matches_data = pd.read_csv(cleaned_matches_path)

# Display the first few rows to check the features
print(cleaned_teams_data.head())
print(cleaned_matches_data.head())

# Example code to check for missing values
print(cleaned_teams_data.isnull().sum())
print(cleaned_matches_data.isnull().sum())

# Fill missing values or drop rows/columns
# cleaned_teams_data.fillna(0, inplace=True)  # Example to fill missing values with 0
# cleaned_matches_data.dropna(inplace=True)   # Example to drop rows with missing values

import pandas as pd

# Replace 'path_to_your_file.csv' with the actual file path
cleaned_matches_data_df = pd.read_csv('/content/cleaned_teams_head_to_head.csv')

# Aggregating player stats by team and season
aggregation_methods = {
    'goals_per_90_overall': 'mean',
    'assists_per_90_overall': 'mean',
    'average_rating_overall': 'mean',
    'clean_sheets_overall': 'sum',
    'goals_overall': 'sum',
    'assists_overall': 'sum',
    'appearances_overall': 'sum',
    'minutes_played_overall': 'sum',
    'yellow_cards_overall': 'sum',
    'red_cards_overall': 'sum',
    'tackles_per_90_overall': 'sum',
    'xg_per_90_overall': 'sum',
    'xa_per_90_overall': 'sum',
    'npxg_per_90_overall': 'sum',
    'interceptions_per_90_overall': 'sum',
    'distance_travelled_per_90_overall': 'sum',
    'aerial_duels_won_per_90_overall': 'sum',
    'shots_on_target_per_90_overall': 'sum',
    'shot_conversion_rate_overall': 'sum',
    'key_passes_per_90_overall': 'sum',
    'through_passes_per_90_overall': 'sum',
    'chances_created_per_90_overall': 'sum',
    'dribbles_per_90_overall': 'sum',
    'dribbles_successful_percentage_overall': 'sum',
    'passes_per_90_overall': 'sum',
    'pass_completion_rate_overall': 'sum',
    'full_name': 'first',
    'age': 'first',
    'position': 'first',
    'league': 'first'
    # Note: Removed 'Current Club' and 'season' as they are already included as part of the groupby
}

aggregated_player_stats = extracted_features_df.groupby(['Current Club', 'season']).agg(aggregation_methods).reset_index()

# Assuming 'home_team_name' and 'away_team_name' in cleaned_matches_data_df
final_dataset = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['common_name', 'season'],
    right_on=['team_name', 'season'],
    how='left'
)

# Assuming 'team_name' in cleaned_teams_data matches 'Current Club' in aggregated_player_stats
merged_team_player_stats = pd.merge(
    cleaned_teams_data,
    aggregated_player_stats,
    left_on=['team_name', 'season'],
    right_on=['Current Club', 'season'],
    how='left'
)

# Specify the file path and name for your downloaded file
download_path = '/content/merged_team_player_stats.csv'

# Save the DataFrame to a CSV file
merged_team_player_stats.to_csv(download_path, index=False)

# Code to download the file to your local system
from google.colab import files
files.download(download_path)
[ ]
# Specify the file path and name for your downloaded file
download_path = '/content/merged_team_player_stats.csv'

# Save the DataFrame to a CSV file
merged_team_player_stats.to_csv(download_path, index=False)

# Code to download the file to your local system
from google.colab import files
files.download(download_path)


[ ]
cleaned_matches_data_df = pd.read_csv('/content/cleaned_matches (2).csv')
print(cleaned_matches_data_df.columns)

Index(['timestamp', 'da

cleaned_matches_data_df = pd.read_csv('/content/cleaned_matches (2).csv')
print(cleaned_matches_data_df.columns)

# Replace 'path_to_your_file' with the actual path of your CSV file
cleaned_matches_data_df = pd.read_csv('/content/cleaned_matches (2).csv')

# Display the first few rows of the DataFrame
print(cleaned_matches_data_df.head())

# Check column names
print(cleaned_matches_data_df.columns)

'cleaned_matches_data_df' in locals() or 'cleaned_matches_data_df' in globals()

print(cleaned_matches_data_df.columns)
print(merged_team_player_stats.columns)

cleaned_matches_data_df['season'] = pd.to_datetime(cleaned_matches_data_df['date_GMT']).dt.year

# Convert 'season' to string in both DataFrames
cleaned_matches_data_df['season'] = cleaned_matches_data_df['season'].astype(str)
merged_team_player_stats['season'] = merged_team_player_stats['season'].astype(str)

# Merge considering 'common_name' as the home team
final_dataset_home = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['home_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Merge considering 'common_name' as the away team
final_dataset_away = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['away_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Validate the merged data
print(final_dataset_home.head())
print(final_dataset_away.head())

# Example: Check unique team names in both DataFrames
print(cleaned_matches_data_df['home_team_name'].unique())
print(merged_team_player_stats['common_name'].unique())

# Extracting team names from the match data
team_names_match_data = set(cleaned_matches_data_df['home_team_name'].tolist() + cleaned_matches_data_df['away_team_name'].tolist())

# Extracting team names from the player stats data
team_names_player_stats = set(merged_team_player_stats['common_name'].tolist())

# Now proceed to compare the lists and find discrepancies
non_matching_names_match_data = team_names_match_data - team_names_player_stats
non_matching_names_player_stats = team_names_player_stats - team_names_match_data

# Print non-matching names for inspection
print("Non-matching in Match Data:", non_matching_names_match_data)
print("Non-matching in Player Stats:", non_matching_names_player_stats)

import pandas as pd

# List all the variables currently in the environment
all_vars = globals().copy()
all_vars.update(locals())

# Filter and print only those variables which are pandas DataFrames
for var_name, var_val in all_vars.items():
    if isinstance(var_val, pd.DataFrame):
        print(f"{var_name}: {type(var_val)} with shape {var_val.shape}")

# Replace 'df_to_use' with the actual DataFrame you want to filter (e.g., extracted_features_df or combined_player_stats)
# Replace 'league_column' with the actual column name that contains league information in your DataFrame

df_to_use = extracted_features_df # or combined_player_stats
english_leagues = ['Premier League', 'Championship', 'FA Cup', 'EFL League One', 'EFL League Two']
filtered_df = df_to_use[df_to_use['league'].isin(english_leagues)]

# Display the first few rows to verify
print(filtered_df.head())

# This will display the first few rows of the DataFrame
cleaned_matches_data_df.head()

# Merge considering 'common_name' as the home team
final_dataset_home = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['home_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# This will display the column names and data types
cleaned_matches_data_df.info()

# This will display the column names in the DataFrame
cleaned_matches_data_df.columns

# Commented out IPython magic to ensure Python compatibility.
# List all variables in the current session
# %who

import pandas as pd

# List all pandas DataFrames
for var in dir():
    if isinstance(eval(var), pd.DataFrame):
        print(var)

print(cleaned_matches_data_df.head())
print(cleaned_teams_data.head())
print(extracted_features_df.head())
print(combined_player_stats.head())
print(seasonal_player_stats.head())

# Exporting the combined_leagues_df DataFrame to a CSV file
combined_leagues_df.to_csv('/content/drive/My Drive/94_betting_model/combined_leagues_data.csv', index=False)

# Extracting specified training features
selected_features = ['Pre-Match PPG (Home)', 'Pre-Match PPG (Away)', 'home_team_goal_count', 'away_team_goal_count', 'average_corners_per_match_pre_match', 'average_cards_per_match_pre_match', 'odds_ft_home_team_win', 'odds_ft_draw', 'odds_ft_away_team_win']
training_data = combined_leagues_df[selected_features]

# Optionally, you can also export the extracted training data
training_data.to_csv('/content/drive/My Drive/94_betting_model/training_data.csv', index=False)

"""THIS NEXT SECTION MIGHT BE THE ABOVE BUT MORE LOGICAL< OR MORE PREPROCESSING"""

file_paths = [
    '/content/spain-la-liga-players-2023-to-2024-stats.xlsx',
    '/content/portugal-liga-nos-players-2023-to-2024-stats.xlsx',
    '/content/italy-serie-a-players-2023-to-2024-stats.xlsx',
    '/content/germany-bundesliga-players-2023-to-2024-stats.xlsx',
    '/content/france-ligue-1-players-2023-to-2024-stats.xlsx',
    '/content/europe-uefa-europa-league-players-2023-to-2024-stats.xlsx',
    '/content/europe-uefa-champions-league-players-2023-to-2024-stats.xlsx',
    '/content/england-premier-league-players-2023-to-2024-stats.xlsx',
    '/content/england-fa-cup-players-2023-to-2024-stats.xlsx',
    '/content/england-efl-league-two-players-2023-to-2024-stats.xlsx',
    '/content/england-efl-league-one-players-2023-to-2024-stats.xlsx',
    '/content/england-championship-players-2023-to-2024-stats.xlsx',

    # Add paths for all your files

dfs = []  # List to store individual DataFrames

for file in file_paths:
    df = pd.read_excel(file)
    dfs.append(df)

combined_player_stats = pd.concat(dfs, ignore_index=True)

print(combined_player_stats.head())

# Assuming you have a DataFrame named 'combined_player_stats' containing all the player statistics
# If you haven't already loaded the data into a DataFrame, do it before running the following code

# List of desired features
features = [
    "full_name", "age", "position", "Current Club", "league", "season",
    "minutes_played_overall", "appearances_overall", "yellow_cards_overall", "red_cards_overall",
    "goals_per_90_overall", "assists_per_90_overall", "xg_per_90_overall", "xa_per_90_overall",
    "npxg_per_90_overall", "clean_sheets_overall", "tackles_per_90_overall", "interceptions_per_90_overall",
    "distance_travelled_per_90_overall", "aerial_duels_won_per_90_overall", "goals_overall",
    "assists_overall", "shots_on_target_per_90_overall", "shot_conversion_rate_overall",
    "key_passes_per_90_overall", "through_passes_per_90_overall", "chances_created_per_90_overall",
    "dribbles_per_90_overall", "dribbles_successful_percentage_overall", "passes_per_90_overall",
    "pass_completion_rate_overall", "average_rating_overall"
]

# Extracting the features
extracted_features_df = combined_player_stats[features]

# Displaying the first few rows of the extracted features DataFrame
print(extracted_features_df.head())

# Check for missing values
missing_values = extracted_features_df.isnull().sum()
print(missing_values)

# Define a threshold for the minimum number of non-missing values required to keep a row
threshold = len(extracted_features_df.columns) - 5  # For example, allow up to 5 missing values

# Filter out rows with missing values above the threshold
extracted_features_df = extracted_features_df.dropna(thresh=threshold)

# Check for missing values after filtering
print(extracted_features_df.isnull().sum())

# Check the size of the DataFrame after filtering
print(extracted_features_df.shape)

from google.colab import files

# Save your cleaned DataFrame to a CSV file
csv_file_path = '/content/cleaned_player_stats.csv'
extracted_features_df.to_csv(csv_file_path, index=False)

# Download the file to your local system
files.download(csv_file_path)

!pip install --upgrade pandas openpyxl

# Dropping specified columns
columns_to_drop = ['attendance', 'booked_over05_percentage_overall',
                   'booked_over05_percentage_percentile_overall',
                   'shirt_number', 'annual_salary_gbp', 'annual_salary_usd']

combined_player_stats.drop(columns=columns_to_drop, inplace=True, errors='ignore')
cleaned_matches_data_df.drop(columns=columns_to_drop, inplace=True, errors='ignore')

# Checking the DataFrame after dropping the columns
print(combined_player_stats.head())
print(cleaned_matches_data_df.head())



import pandas as pd

# Load the datasets
cleaned_teams_path = 'cleaned_teams_head_to_head.csv'
cleaned_matches_path = 'cleaned_matches.csv'

# Read the data into pandas dataframes
cleaned_teams_data = pd.read_csv(cleaned_teams_path)
cleaned_matches_data = pd.read_csv(cleaned_matches_path)

# Display the first few rows to check the features
print(cleaned_teams_data.head())
print(cleaned_matches_data.head())

# Example code to check for missing values
print(cleaned_teams_data.isnull().sum())
print(cleaned_matches_data.isnull().sum())

# Fill missing values or drop rows/columns
# cleaned_teams_data.fillna(0, inplace=True)  # Example to fill missing values with 0
# cleaned_matches_data.dropna(inplace=True)   # Example to drop rows with missing values

import pandas as pd

# Replace 'path_to_your_file.csv' with the actual file path
cleaned_matches_data_df = pd.read_csv('/content/cleaned_teams_head_to_head.csv')

# Aggregating player stats by team and season
aggregation_methods = {
    'goals_per_90_overall': 'mean',
    'assists_per_90_overall': 'mean',
    'average_rating_overall': 'mean',
    'clean_sheets_overall': 'sum',
    'goals_overall': 'sum',
    'assists_overall': 'sum',
    'appearances_overall': 'sum',
    'minutes_played_overall': 'sum',
    'yellow_cards_overall': 'sum',
    'red_cards_overall': 'sum',
    'tackles_per_90_overall': 'sum',
    'xg_per_90_overall': 'sum',
    'xa_per_90_overall': 'sum',
    'npxg_per_90_overall': 'sum',
    'interceptions_per_90_overall': 'sum',
    'distance_travelled_per_90_overall': 'sum',
    'aerial_duels_won_per_90_overall': 'sum',
    'shots_on_target_per_90_overall': 'sum',
    'shot_conversion_rate_overall': 'sum',
    'key_passes_per_90_overall': 'sum',
    'through_passes_per_90_overall': 'sum',
    'chances_created_per_90_overall': 'sum',
    'dribbles_per_90_overall': 'sum',
    'dribbles_successful_percentage_overall': 'sum',
    'passes_per_90_overall': 'sum',
    'pass_completion_rate_overall': 'sum',
    'full_name': 'first',
    'age': 'first',
    'position': 'first',
    'league': 'first'
    # Note: Removed 'Current Club' and 'season' as they are already included as part of the groupby
}

aggregated_player_stats = extracted_features_df.groupby(['Current Club', 'season']).agg(aggregation_methods).reset_index()

# Assuming 'team_name' in cleaned_teams_data matches 'Current Club' in aggregated_player_stats
merged_team_player_stats = pd.merge(
    cleaned_teams_data,
    aggregated_player_stats,
    left_on=['team_name', 'season'],
    right_on=['Current Club', 'season'],
    how='left'
)

# Assuming 'home_team_name' and 'away_team_name' in cleaned_matches_data_df
final_dataset = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['common_name', 'season'],
    right_on=['team_name', 'season'],
    how='left'
)

print(cleaned_matches_data_df.columns)

# Specify the file path and name for your downloaded file
download_path = '/content/merged_team_player_stats.csv'

# Save the DataFrame to a CSV file
merged_team_player_stats.to_csv(download_path, index=False)

# Code to download the file to your local system
from google.colab import files
files.download(download_path)

cleaned_matches_data_df = pd.read_csv('/content/cleaned_matches (2).csv')
print(cleaned_matches_data_df.columns)

# Replace 'path_to_your_file' with the actual path of your CSV file
cleaned_matches_data_df = pd.read_csv('/content/cleaned_matches (2).csv')

# Display the first few rows of the DataFrame
print(cleaned_matches_data_df.head())

# Check column names
print(cleaned_matches_data_df.columns)

'cleaned_matches_data_df' in locals() or 'cleaned_matches_data_df' in globals()

print(cleaned_matches_data_df.columns)
print(merged_team_player_stats.columns)

cleaned_matches_data_df['season'] = pd.to_datetime(cleaned_matches_data_df['date_GMT']).dt.year

# Convert 'season' to string in both DataFrames
cleaned_matches_data_df['season'] = cleaned_matches_data_df['season'].astype(str)
merged_team_player_stats['season'] = merged_team_player_stats['season'].astype(str)

# Merge considering 'common_name' as the home team
final_dataset_home = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['home_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Merge considering 'common_name' as the away team
final_dataset_away = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['away_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Validate the merged data
print(final_dataset_home.head())
print(final_dataset_away.head())

# Example: Check unique team names in both DataFrames
print(cleaned_matches_data_df['home_team_name'].unique())
print(merged_team_player_stats['common_name'].unique())

# Extracting team names from the match data
team_names_match_data = set(cleaned_matches_data_df['home_team_name'].tolist() + cleaned_matches_data_df['away_team_name'].tolist())

# Extracting team names from the player stats data
team_names_player_stats = set(merged_team_player_stats['common_name'].tolist())

# Now proceed to compare the lists and find discrepancies
non_matching_names_match_data = team_names_match_data - team_names_player_stats
non_matching_names_player_stats = team_names_player_stats - team_names_match_data

# Print non-matching names for inspection
print("Non-matching in Match Data:", non_matching_names_match_data)
print("Non-matching in Player Stats:", non_matching_names_player_stats)

english_leagues = ['Premier League', 'Championship', 'FA Cup', 'League One', 'League Two']
filtered_df = original_df[original_df['league'].isin(english_leagues)]

import pandas as pd

# List all the variables currently in the environment
all_vars = globals().copy()
all_vars.update(locals())

# Filter and print only those variables which are pandas DataFrames
for var_name, var_val in all_vars.items():
    if isinstance(var_val, pd.DataFrame):
        print(f"{var_name}: {type(var_val)} with shape {var_val.shape}")

# Replace 'df_to_use' with the actual DataFrame you want to filter (e.g., extracted_features_df or combined_player_stats)
# Replace 'league_column' with the actual column name that contains league information in your DataFrame

df_to_use = extracted_features_df # or combined_player_stats
english_leagues = ['Premier League', 'Championship', 'FA Cup', 'EFL League One', 'EFL League Two']
filtered_df = df_to_use[df_to_use['league'].isin(english_leagues)]

# Display the first few rows to verify
print(filtered_df.head())



# This will display the first few rows of the DataFrame
cleaned_matches_data_df.head()

# Merge considering 'common_name' as the home team
final_dataset_home = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['home_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Merge considering 'common_name' as the away team
final_dataset_away = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['away_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# This will display the column names and data types
cleaned_matches_data_df.info()

# This will display the column names in the DataFrame
cleaned_matches_data_df.columns

# Commented out IPython magic to ensure Python compatibility.
# List all variables in the current session
# %who

import pandas as pd

# List all pandas DataFrames
for var in dir():
    if isinstance(eval(var), pd.DataFrame):
        print(var)

print(cleaned_matches_data_df.head())
print(cleaned_teams_data.head())
print(extracted_features_df.head())
print(combined_player_stats.head())
print(seasonal_player_stats.head())

# Example code to convert data types
# cleaned_teams_data['some_column'] = cleaned_teams_data['some_column'].astype(float)
# cleaned_matches_data['another_column'] = cleaned_matches_data['another_column'].astype(int)

import pandas as pd

# Check for missing values
missing_values = extracted_features_df.isnull().sum()
print(missing_values)

file_paths = [


    # Add paths for all your files
]

!pip install openpyxl
import pandas as pd

file_paths = [


    # Add paths for all your files
]

dfs = []  # List to store individual DataFrames

for file in file_paths:
    df = pd.read_excel(file)
    dfs.append(df)

combined_player_stats = pd.concat(dfs, ignore_index=True)

print(combined_player_stats.head())

# Assuming you have a DataFrame named 'combined_player_stats' containing all the player statistics
# If you haven't already loaded the data into a DataFrame, do it before running the following code

# List of desired features
features = [
    "full_name", "age", "position", "Current Club", "league", "season",
    "minutes_played_overall", "appearances_overall", "yellow_cards_overall", "red_cards_overall",
    "goals_per_90_overall", "assists_per_90_overall", "xg_per_90_overall", "xa_per_90_overall",
    "npxg_per_90_overall", "clean_sheets_overall", "tackles_per_90_overall", "interceptions_per_90_overall",
    "distance_travelled_per_90_overall", "aerial_duels_won_per_90_overall", "goals_overall",
    "assists_overall", "shots_on_target_per_90_overall", "shot_conversion_rate_overall",
    "key_passes_per_90_overall", "through_passes_per_90_overall", "chances_created_per_90_overall",
    "dribbles_per_90_overall", "dribbles_successful_percentage_overall", "passes_per_90_overall",
    "pass_completion_rate_overall", "average_rating_overall"
]

# Extracting the features
extracted_features_df = combined_player_stats[features]

# Displaying the first few rows of the extracted features DataFrame
print(extracted_features_df.head())

# Check for missing values
missing_values = extracted_features_df.isnull().sum()
print(missing_values)

# Define a threshold for the minimum number of non-missing values required to keep a row
threshold = len(extracted_features_df.columns) - 5  # For example, allow up to 5 missing values

# Filter out rows with missing values above the threshold
extracted_features_df = extracted_features_df.dropna(thresh=threshold)



# Check for missing values after filtering
print(extracted_features_df.isnull().sum())

# Check the size of the DataFrame after filtering
print(extracted_features_df.shape)

from google.colab import files

# Save your cleaned DataFrame to a CSV file
csv_file_path = '/content/cleaned_player_stats.csv'
extracted_features_df.to_csv(csv_file_path, index=False)

# Download the file to your local system
files.download(csv_file_path)

# Assuming 'extracted_features_df' has a 'Current Club' column that matches the team name in your match data

# If necessary, standardize team names across datasets
extracted_features_df['Current Club'] = extracted_features_df['Current Club'].str.strip().str.lower()
match_stats_df['home_team_name'] = match_stats_df['home_team_name'].str.strip().str.lower()
match_stats_df['away_team_name'] = match_stats_df['away_team_name'].str.strip().str.lower()



"""SECOND LOAD FOR CLEANED AND MERGED TEAMS, MATCHES, HEAD TO HEAD"""

import pandas as pd

# Paths to your datasets
teams_path = '/content/drive/My Drive/94_betting_model/cleaned_teams.csv'
matches_path = '/content/drive/My Drive/94_betting_model/cleaned_matches.csv'
head_to_head_path = '/content/drive/My Drive/94_betting_model/head_to_head.csv'

# Load datasets
teams_df = pd.read_csv(teams_path)
matches_df = pd.read_csv(matches_path)
head_to_head_df = pd.read_csv(head_to_head_path)

# Preliminary cleaning steps (e.g., handling missing values)
teams_df.fillna(0, inplace=True)
matches_df.dropna(inplace=True)

import pandas as pd

# Load the datasets
cleaned_teams_path = 'cleaned_teams_head_to_head.csv'
cleaned_matches_path = 'cleaned_matches.csv'

# Read the data into pandas dataframes
cleaned_teams_data = pd.read_csv(cleaned_teams_path)
cleaned_matches_data = pd.read_csv(cleaned_matches_path)

# Display the first few rows to check the features
print(cleaned_teams_data.head())
print(cleaned_matches_data.head())

# Example code to check for missing values
print(cleaned_teams_data.isnull().sum())
print(cleaned_matches_data.isnull().sum())

# Fill missing values or drop rows/columns
# cleaned_teams_data.fillna(0, inplace=True)  # Example to fill missing values with 0
# cleaned_matches_data.dropna(inplace=True)   # Example to drop rows with missing values

import pandas as pd

# Replace 'path_to_your_file.csv' with the actual file path
cleaned_matches_data_df = pd.read_csv('/content/drive/My Drive/94_betting_model/cleaned_teams_head_to_head.csv')

# Aggregating player stats by team and season
aggregation_methods = {
    'goals_per_90_overall': 'mean',
    'assists_per_90_overall': 'mean',
    'average_rating_overall': 'mean',
    'clean_sheets_overall': 'sum',
    'goals_overall': 'sum',
    'assists_overall': 'sum',
    'appearances_overall': 'sum',
    'minutes_played_overall': 'sum',
    'yellow_cards_overall': 'sum',
    'red_cards_overall': 'sum',
    'tackles_per_90_overall': 'sum',
    'xg_per_90_overall': 'sum',
    'xa_per_90_overall': 'sum',
    'npxg_per_90_overall': 'sum',
    'interceptions_per_90_overall': 'sum',
    'distance_travelled_per_90_overall': 'sum',
    'aerial_duels_won_per_90_overall': 'sum',
    'shots_on_target_per_90_overall': 'sum',
    'shot_conversion_rate_overall': 'sum',
    'key_passes_per_90_overall': 'sum',
    'through_passes_per_90_overall': 'sum',
    'chances_created_per_90_overall': 'sum',
    'dribbles_per_90_overall': 'sum',
    'dribbles_successful_percentage_overall': 'sum',
    'passes_per_90_overall': 'sum',
    'pass_completion_rate_overall': 'sum',
    'full_name': 'first',
    'age': 'first',
    'position': 'first',
    'league': 'first'
    # Note: Removed 'Current Club' and 'season' as they are already included as part of the groupby
}

aggregated_player_stats = extracted_features_df.groupby(['Current Club', 'season']).agg(aggregation_methods).reset_index()

# Assuming 'team_name' in cleaned_teams_data matches 'Current Club' in aggregated_player_stats
merged_team_player_stats = pd.merge(
    cleaned_teams_data,
    aggregated_player_stats,
    left_on=['team_name', 'season'],
    right_on=['Current Club', 'season'],
    how='left'
)

# Assuming 'home_team_name' and 'away_team_name' in cleaned_matches_data_df
final_dataset = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['common_name', 'season'],
    right_on=['team_name', 'season'],
    how='left'
)

print(cleaned_matches_data_df.columns)

# Specify the file path and name for your downloaded file
download_path = '/content/merged_team_player_stats.csv'

# Save the DataFrame to a CSV file
merged_team_player_stats.to_csv(download_path, index=False)

# Code to download the file to your local system
from google.colab import files
files.download(download_path)

cleaned_matches_data_df = pd.read_csv('/content/cleaned_matches (2).csv')
print(cleaned_matches_data_df.columns)

# Replace 'path_to_your_file' with the actual path of your CSV file
cleaned_matches_data_df = pd.read_csv('/content/cleaned_matches (2).csv')

# Display the first few rows of the DataFrame
print(cleaned_matches_data_df.head())

# Check column names
print(cleaned_matches_data_df.columns)

'cleaned_matches_data_df' in locals() or 'cleaned_matches_data_df' in globals()

print(cleaned_matches_data_df.columns)
print(merged_team_player_stats.columns)

cleaned_matches_data_df['season'] = pd.to_datetime(cleaned_matches_data_df['date_GMT']).dt.year

# Convert 'season' to string in both DataFrames
cleaned_matches_data_df['season'] = cleaned_matches_data_df['season'].astype(str)
merged_team_player_stats['season'] = merged_team_player_stats['season'].astype(str)

# Merge considering 'common_name' as the home team
final_dataset_home = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['home_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Merge considering 'common_name' as the away team
final_dataset_away = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['away_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Validate the merged data
print(final_dataset_home.head())
print(final_dataset_away.head())

# Example: Check unique team names in both DataFrames
print(cleaned_matches_data_df['home_team_name'].unique())
print(merged_team_player_stats['common_name'].unique())

# Extracting team names from the match data
team_names_match_data = set(cleaned_matches_data_df['home_team_name'].tolist() + cleaned_matches_data_df['away_team_name'].tolist())

# Extracting team names from the player stats data
team_names_player_stats = set(merged_team_player_stats['common_name'].tolist())

# Now proceed to compare the lists and find discrepancies
non_matching_names_match_data = team_names_match_data - team_names_player_stats
non_matching_names_player_stats = team_names_player_stats - team_names_match_data

# Print non-matching names for inspection
print("Non-matching in Match Data:", non_matching_names_match_data)
print("Non-matching in Player Stats:", non_matching_names_player_stats)

english_leagues = ['Premier League', 'Championship', 'FA Cup', 'League One', 'League Two']
filtered_df = original_df[original_df['league'].isin(english_leagues)]

import pandas as pd

# List all the variables currently in the environment
all_vars = globals().copy()
all_vars.update(locals())

# Filter and print only those variables which are pandas DataFrames
for var_name, var_val in all_vars.items():
    if isinstance(var_val, pd.DataFrame):
        print(f"{var_name}: {type(var_val)} with shape {var_val.shape}")

# Replace 'df_to_use' with the actual DataFrame you want to filter (e.g., extracted_features_df or combined_player_stats)
# Replace 'league_column' with the actual column name that contains league information in your DataFrame

df_to_use = extracted_features_df # or combined_player_stats
english_leagues = ['Premier League', 'Championship', 'FA Cup', 'EFL League One', 'EFL League Two']
filtered_df = df_to_use[df_to_use['league'].isin(english_leagues)]

# Display the first few rows to verify
print(filtered_df.head())



# This will display the first few rows of the DataFrame
cleaned_matches_data_df.head()

# Merge considering 'common_name' as the home team
final_dataset_home = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['home_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# Merge considering 'common_name' as the away team
final_dataset_away = pd.merge(
    cleaned_matches_data_df,
    merged_team_player_stats,
    left_on=['away_team_name', 'season'],
    right_on=['common_name', 'season'],
    how='left'
)

# This will display the column names and data types
cleaned_matches_data_df.info()

# This will display the column names in the DataFrame
cleaned_matches_data_df.columns

# Commented out IPython magic to ensure Python compatibility.
# List all variables in the current session
# %who

import pandas as pd

# List all pandas DataFrames
for var in dir():
    if isinstance(eval(var), pd.DataFrame):
        print(var)

print(cleaned_matches_data_df.head())
print(cleaned_teams_data.head())
print(extracted_features_df.head())
print(combined_player_stats.head())
print(seasonal_player_stats.head())

# Example code to convert data types
# cleaned_teams_data['some_column'] = cleaned_teams_data['some_column'].astype(float)
# cleaned_matches_data['another_column'] = cleaned_matches_data['another_column'].astype(int)

import pandas as pd

# Check for missing values
missing_values = extracted_features_df.isnull().sum()
print(missing_values)

file_paths = [
    '/content/spain-la-liga-players-2023-to-2024-stats.xlsx',
    '/content/portugal-liga-nos-players-2023-to-2024-stats.xlsx',
    '/content/italy-serie-a-players-2023-to-2024-stats.xlsx',
    '/content/germany-bundesliga-players-2023-to-2024-stats.xlsx',
    '/content/france-ligue-1-players-2023-to-2024-stats.xlsx',
    '/content/europe-uefa-europa-league-players-2023-to-2024-stats.xlsx',
    '/content/europe-uefa-champions-league-players-2023-to-2024-stats.xlsx',
    '/content/england-premier-league-players-2023-to-2024-stats.xlsx',
    '/content/england-fa-cup-players-2023-to-2024-stats.xlsx',
    '/content/england-efl-league-two-players-2023-to-2024-stats.xlsx',
    '/content/england-efl-league-one-players-2023-to-2024-stats.xlsx',
    '/content/england-championship-players-2023-to-2024-stats.xlsx',

    # Add paths for all your files
]

!pip install openpyxl
import pandas as pd

file_paths = [
    '/content/spain-la-liga-players-2023-to-2024-stats.xlsx',
    '/content/portugal-liga-nos-players-2023-to-2024-stats.xlsx',
    '/content/italy-serie-a-players-2023-to-2024-stats.xlsx',
    '/content/germany-bundesliga-players-2023-to-2024-stats.xlsx',
    '/content/france-ligue-1-players-2023-to-2024-stats.xlsx',
    '/content/europe-uefa-europa-league-players-2023-to-2024-stats.xlsx',
    '/content/europe-uefa-champions-league-players-2023-to-2024-stats.xlsx',
    '/content/england-premier-league-players-2023-to-2024-stats.xlsx',
    '/content/england-fa-cup-players-2023-to-2024-stats.xlsx',
    '/content/england-efl-league-two-players-2023-to-2024-stats.xlsx',
    '/content/england-efl-league-one-players-2023-to-2024-stats.xlsx',
    '/content/england-championship-players-2023-to-2024-stats.xlsx',

    # Add paths for all your files
]

dfs = []  # List to store individual DataFrames

for file in file_paths:
    df = pd.read_excel(file)
    dfs.append(df)

combined_player_stats = pd.concat(dfs, ignore_index=True)

print(combined_player_stats.head())

# Assuming you have a DataFrame named 'combined_player_stats' containing all the player statistics
# If you haven't already loaded the data into a DataFrame, do it before running the following code

# List of desired features
features = [
    "full_name", "age", "position", "Current Club", "league", "season",
    "minutes_played_overall", "appearances_overall", "yellow_cards_overall", "red_cards_overall",
    "goals_per_90_overall", "assists_per_90_overall", "xg_per_90_overall", "xa_per_90_overall",
    "npxg_per_90_overall", "clean_sheets_overall", "tackles_per_90_overall", "interceptions_per_90_overall",
    "distance_travelled_per_90_overall", "aerial_duels_won_per_90_overall", "goals_overall",
    "assists_overall", "shots_on_target_per_90_overall", "shot_conversion_rate_overall",
    "key_passes_per_90_overall", "through_passes_per_90_overall", "chances_created_per_90_overall",
    "dribbles_per_90_overall", "dribbles_successful_percentage_overall", "passes_per_90_overall",
    "pass_completion_rate_overall", "average_rating_overall"
]

# Extracting the features
extracted_features_df = combined_player_stats[features]

# Displaying the first few rows of the extracted features DataFrame
print(extracted_features_df.head())

# Check for missing values
missing_values = extracted_features_df.isnull().sum()
print(missing_values)

# Define a threshold for the minimum number of non-missing values required to keep a row
threshold = len(extracted_features_df.columns) - 5  # For example, allow up to 5 missing values

# Filter out rows with missing values above the threshold
extracted_features_df = extracted_features_df.dropna(thresh=threshold)



# Check for missing values after filtering
print(extracted_features_df.isnull().sum())

# Check the size of the DataFrame after filtering
print(extracted_features_df.shape)

from google.colab import files

# Save your cleaned DataFrame to a CSV file
csv_file_path = '/content/cleaned_player_stats.csv'
extracted_features_df.to_csv(csv_file_path, index=False)

# Download the file to your local system
files.download(csv_file_path)

# Assuming 'extracted_features_df' has a 'Current Club' column that matches the team name in your match data

# If necessary, standardize team names across datasets
extracted_features_df['Current Club'] = extracted_features_df['Current Club'].str.strip().str.lower()
match_stats_df['home_team_name'] = match_stats_df['home_team_name'].str.strip().str.lower()
match_stats_df['away_team_name'] = match_stats_df['away_team_name'].str.strip().str.lower()

!pip install --upgrade pandas openpyxl